
pragma solidity ^0.8.20;

contract CompressedLibrary1 {
    string public data;

    constructor() {
        data = ",v=V(g),x=b(v,-1),w=d(x,1),M=y(w,2),K=p(x,1),_=y(K,-2),E=A(g),S=b(E,.5),I=C(n),T=y(S,I),z=b(T,-1),O=b(T,I),k=b(O,-1),j=d(T,1),P=Ke(c,M,_,z,k,1,j),L=H(j),N=b(L,s),D=b(P,N),R=b(h,D),F=e,B=u(e),q=b(x,2),W=Ke(c,w,K,0,0,q,q),Z=b(W,N),U=b(u(),Z),G=Q(T,1),J=Ke(c,M,_,T,O,1,G),X=b(J,N),Y=b(F,X),ee=d(dt(dt($),R),dt(dt(B),U),Y),te=r(o()),ne=b(G,L),ie=b(te,ne),ae=b(q,L),re=b(o(),ae),oe=d(dt(dt(m),ie),re),le=p(ee,oe),ue=o(le),me=o(le);return ve(\"biquad\",dt(m,ue,B,$,me))(a)})),Ee=(e,t,n,s,i)=>o((a=>{let r=se(),o=se(),l=se(),u=se(),m=r(o()),$=e,h=d(i,1),c=C(t),f=b(c,.00014247585730565955),g=V(f),v=b(g,-1),x=d(v,1),w=y(x,2),M=p(v,1),K=y(M,-2),_=A(f),E=b(_,.5),S=C(n),I=y(E,S),T=b(I,S),z=Q(I,1),O=Ke(h,w,K,I,T,1,z),k=d(I,1),j=H(k),P=b(j,s),L=b(O,P),N=b($,L),D=l(e),R=b(v,2),F=Ke(h,x,M,0,0,R,R),B=b(F,P),q=b(l(),B),W=u(l()),Z=b(I,-1),U=b(T,-1),G=Ke(h,w,K,Z,U,1,k),J=b(G,P),X=b(J,u()),Y=d(N,dt(dt(D),q),dt(dt(W),X)),ee=b(R,j),te=b(o(),ee),ne=p(Y,te),ie=b(z,j),ae=b(ie,r()),re=o(p(ne,dt(dt(m),ae)));return dt(m,re,D,W,re)(a)})),Ce=(e,t)=>o((n=>{const s=se(),i=q(e,s(),t);return ve(\"onepole\",s(i))(n)})),Se=(e,t,n)=>o((s=>{let i=ct(F(1,xt(q(n,t,e))));return ve(\"vactrol\",Ce(e,i))(s)})),Ie=(e,t,n,s)=>o((i=>{let a=se(),r=se(),o=e,l=b(t,.7853981633974483),u=T(l),m=d(u,1),$=y(u,m),h=H(n),c=d($,h),f=b(r(),c),g=d(a(),f),v=p(o,g),x=b($,$),w=b($,h),M=d(x,w),K=d(M,1),_=H(K),E=b(v,_),C=b(E,$),S=d(C,r()),I=b(S,$),A=d(I,a()),V=a(d(A,I)),z=r(d(C,S)),O=((e,...t)=>n=>{let s=n.gen(e),i=t.map((e=>n.gen(e))),[a,r,o,l,u,m,d,$,h,p,c,b]=n.useVariables(\"interp\",\"mt\",\"mt2\",\"mt3\",\"t\",\"t2\",\"t3\",\"c0\",\"c1\",\"c2\",\"c3\",\"c4\",\"c5\"),y=\"\";return 2===i.length?y=`\\n${n.varKeyword} ${r} = 1 - ${s.variable};\\n${n.varKeyword} ${$} = ${i[0].variable} * ${r};\\n${n.varKeyword} ${h} = ${i[1].variable} * ${s.variable};\\n${n.varKeyword} ${a} = ${$} + ${h};\\n`:3===i.length?y=`\\n${n.varKeyword} ${r} = 1 - ${s.variable};\\n${n.varKeyword} ${d} = ${i[0].variable} * ${r} * ${r};\\n${n.varKeyword} ${$} = 2 * ${i[1].variable} * ${r} * ${s.variable};\\n${n.varKeyword} ${h} = ${i[2].variable} * ${s.variable} * ${s.variable};\\n\\n${n.varKeyword} ${a} = ${d} + ${$} + ${h};\\n`:4===i.length?y=`\\n${n.varKeyword} ${r} = 1 - ${s.variable};\\n${n.varKeyword} ${o} = ${r} * ${r};\\n${n.varKeyword} ${u} = ${s.variable} * ${s.variable};\\n${n.varKeyword} ${d} = ${i[0].variable} * ${o} * ${r};\\n${n.varKeyword} ${$} = 3 * ${i[1].variable} * ${o} * ${s.variable};\\n${n.varKeyword} ${h} = 3 * ${i[2].variable} * ${r} * ${u};\\n${n.varKeyword} ${p} = ${i[3].variable} * ${u} * ${s.variable};\\n\\n${n.varKeyword} ${a} = ${d} + ${$} + ${h} + ${p};\\n`:6===i.length&&(y=`\\n${n.varKeyword} ${r} = 1 - ${s.variable};\\n${n.varKeyword} ${o} = ${r} * ${r};\\n${n.varKeyword} ${l} = ${o} * ${r};\\n${n.varKeyword} ${u} = ${s.variable} * ${s.variable};\\n${n.varKeyword} ${m} = ${u} * ${s.variable};\\n${n.varKeyword} ${d} = ${i[0].variable} * ${l} * ${o};\\n${n.varKeyword} ${$} = 5 * ${i[1].variable} * ${l} * ${s.variable};\\n${n.varKeyword} ${h} = 10 * ${i[2].variable} * ${o} * ${u};\\n${n.varKeyword} ${p} = 10 * ${i[3].variable} * ${r} * ${m};\\n${n.varKeyword} ${c} = 5 * ${i[4].variable} * ${m} * ${u};\\n${n.varKeyword} ${b} = ${i[5].variable} * ${m} * ${m};\\n\\n${n.varKeyword} ${a} = ${d} + ${$} + ${h} + ${p} + ${c} + ${b};\\n`),n.emit(y,a,s,...i)})(s,dt(dt(V),A),E,dt(dt(z),S));return dt(V,z,O)(i)})),Ae=e=>t=>{let n=t.gen(e),s=`\\nif (${n.variable}) {\\n  break;\\n}\\n`;return t.emit(s,\"\",n)},Te=(e,t,n,s,i=.01,a=.05)=>{const r=b(20,j(F(C(e),1e-5))),o=N(y(O(.01),b(i,44100))),l=N(y(O(.01),b(a,44100))),u=p(r,n),m=d(u,b(.5,s)),$=rt(v(u,b(-.5,s)),rt(f(u,b(.5,s)),b(y(p(t,1),b(2,s)),b(m,m)),b(u,p(t,1))),0),h=se();return dt(h(rt(v($,h()),d(b(o,h()),b($,p(1,o))),d(b(l,h()),b($,p(1,l))))),b(B(e),(c=p(r,h()),P(10,y(c,20)))));var c},Ve=(e=1,t=1,n,s,i)=>{let a,r,o,l=[],u=!1,m=i=>{u=!0,o&&(n=o);let m=i;if(void 0===a||r!==i){if(s)for(;\"context\"in m;)m=m.context;i=m,(!a||i.context!==r&&r.context!==i)&&(i===r||(a=i.alloc(e*t))),a.initData=n,a.length=e,a.channels=t,l.push({block:a,context:i})}return r=i,a.channels=t,a.length=e,null!=n&&(a.initData=n),i.memory.blocksInUse.push(a),a};return m.get=()=>a?a.get():new Promise((e=>e(new Float32Array(1)))),m.interpolation=void 0===i?\"linear\":i,m.getSize=()=>e,m.getChannels=()=>t,m.getInitData=()=>n,m.set=(e,t)=>{o=e;for(let{context:n,block:s}of l)s.initData=e,n.postMessage({type:\"init-memory\",body:{idx:s.idx,data:e,time:t}})},m},ze=(t,n,s,i)=>o((a=>{let r=a,o=a;for(;\"context\"in a;)a=a.context;let l,m=t(a),d=r.gen(n),$=r.gen(s),[h,p,c,b,y,f,g,v]=r.useVariables(\"preIdx\",\"peekIdx\",\"peekVal\",\"channelIdx\",\"frac\",\"nextIdx\",\"peekIdx2\",\"peekIdx3\"),x=m.length,w=(m.length,m.length);i&&(l=r.gen(i),w=l.variable);let M=void 0===m._idx?m.idx:m._idx,K=a.intKeyword,_=a.varKeyword,E=a.target===e.C?u[\"Math.floor\"]:\"Math.floor\",C=`\\n${_} ${h} = ${d.variable};\\nif (${h} > ${m.length} - 1) ${h} = 0; //${m.length};\\nelse if (${h} < 0) ${h} += ${m.length};\\n${K} ${b} = ${$.variable};\\nif (${b} > ${m.channels}) ${b} -= ${m.channels};\\nelse if (${b} < 0) ${b} += ${m.channels};\\n${_} ${p} = ${x} * ${b} + ${h};\\n${_} ${y} = ${p} - ${E}(${p});\\n${K} ${f} = ${E}(${p}) + 1;\\nif (${f} >= ${x} * (${$.variable} + ${w})) {\\n   ${f} =  ${x} * (${$.variable});\\n}\\n${K} ${g} = ${M} + ${E}(${p});\\n${K} ${v} = ${M} + ${f};\\n${_} ${c} = (1 - ${y})*memory[${g}] + (${y})*memory[${v}];\\n`;return\"none\"===t.interpolation&&(C=`\\n${K} ${h} = ${d.variable};\\nif (${h} > ${m.length}) ${h} -= ${m.length};\\nelse if (${h} < 0) ${h} += ${m.length};\\n${K} ${b} = ${$.variable};\\nif (${b} > ${m.channels}) ${b} -= ${m.channels};\\nelse if (${b} < 0) ${b} += ${m.channels};\\n${K} ${p} = ${x} * ${b} + ${h};\\n${K} ${g} = ${M} + ${p};\\n${_} ${c} = memory[${g}];\\n`),l?a.emit(C,c,d,$,l):o.emit(C,c,d,$)})),Oe=(t,n,s,i)=>o((a=>{let r=t(a),o=a.gen(n),[l]=a.useVariables(\"pokeIdx2\"),m=a.gen(s),d=a.gen(i),$=r.length,h=a.intKeyword,p=(a.varKeyword,a.target===e.C?u[\"Math.floor\"]:\"Math.floor\"),c=`${$} * ${m.variable} + ${p}(${o.variable})`,b=`\\n// begin poke\\n${h} ${l} = ${r._idx||r.idx} + ${c};\\nmemory[${l}] = ${d.variable};\\n// end poke\\n`;return a.emit(b,d.variable,o,m,d)})),ke=(t,n)=>o((s=>{let i=t(s),[a]=s.useVariables(\"pokeIdx2\"),r=s.gen(n),o=i.length,l=s.intKeyword,m=(s.target===e.C&&u[\"Math.floor\"],`\\nfor (${l} i=0; i < ${o}; i++) {\\n   memory[${i._idx||i.idx} + i] = ${r.variable};\\n}\\n${l} ${a} = ${i._idx||i.idx} + 0;\\n`);return s.emit(m,r.variable,r)})),je=e=>o((t=>{let n=se();return p(e,n(e))(t)})),Pe=e=>o((t=>{let n=se();return B(p(e,n(e)))(t)})),Le=e=>o((t=>{let n=se()(e);return f(0,Pe(f(.5,C(y(p(e,n),d(e,n))))))(t)})),Ne=(t,n)=>{let s=Ve(176401,1);return o((i=>{let a=s(i),r=i.gen(t),o=i.gen(n),[l,m,d]=i.useVariables(\"delayVal\",\"index\",\"delayIndex\"),$=accum(1,0,{min:0,max:176400,exclusive:!0})(i),h=`${a.idx} + (${$.variable})`,p=((t,n,s,i=\"memory\")=>{let a=t.idx++,r=`frac${a}`,o=`lerpVal${a}`,l=`nextIdx${a}`,m=`flooredName${a}`,d=t.target===e.C?u[\"Math.floor\"]:\"Math.floor\";return{params:[],code:`\\n/** lerp begin **/\\n${t.varKeyword} ${r} = ${s} - ${d}(${s});\\n${t.target===e.C?\"int\":\"let\"} ${m} = ${d}(${s});\\n${t.target===e.C?\"int\":\"let\"} ${l} = ${m} + 1;\\nif ((${l}) - (${n.idx}) >= ${n.length} - 1) ${l} = ${n.idx};\\n${t.varKeyword} ${o} = (1.0-${r})*${i}[${m}] + ${r}*${i}[${l}];\\n//${t.varKeyword} ${o} = ${i}[${m}];\\n/** lerp end **/\\n`,variable:o,histories:[],functions:[],variables:[o],functionArguments:[]}})(i,a,d),c=`\\n// delay code\\n${$.code}\\n${i.target===e.C?\"int\":\"let\"} ${m} = ${h};\\nmemory[${m}] = ${r.variable};\\n${i.target===e.C?\"double\":\"let\"} ${d} = ${m} - ${o.variable};\\nif (${d} < ${a.idx}) {\\n  ${d} += 176400;\\n} else if (${d} >= ${a.idx} + ${a.length} - 1) {\\n  ${d} -= 176400;\\n}\\n${p.code}\\n${i.varKeyword} ${l} = ${p.variable};\\n`;return i.emit(c,l,r,o)}))},De=(e,t=0)=>o((n=>{let[s]=n.useVariables(\"latchVal\"),i=n.gen(e),a=n.gen(t),r=n.alloc(1),o=`${n.varKeyword} ${s} = memory[${r.idx}];\\nif (${a.variable} > 0) {\\n  memory[${r.idx}] = ${i.variable};\\n  ${s} = memory[${r.idx}];\\n}`;return n.emit(o,s,i,a)})),Re=(e,t,n)=>e.split(t).join(n);var Fe=function(e,t,n,s){return new(n||(n=Promise))((function(i,a){function r(e){try{l(s.next(e))}catch(e){a(e)}}function o(e){try{l(s.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,o)}l((s=s.apply(e,t||[])).next())}))};const Be=(t,n,s=\"Zen\",i=!1)=>new Promise((a=>Fe(void 0,void 0,void 0,(function*(){let{code:r,wasm:o}=qe(s,n);console.log(r);let l=r;const u=`data:application/javascript;base64,${btoa(l)}`,m=()=>{console.log(\"NUMBER OF INPUTS=\",n.numberOfInputs);const r=new AudioWorkletNode(t,s,{channelInterpretation:\"discrete\",numberOfInputs:n.numberOfInputs,numberOfOutputs:1,channelCount:n.numberOfOutputs,outputChannelCount:[n.numberOfOutputs]});return r.port.onmessage=t=>{let s=t.data.type,i=t.data.body;n.context.onMessage({type:s,body:i}),n.context.target===e.C&&\"wasm-ready\"===s&&(Ye(n.context,r),r.port.postMessage({type:\"ready\"}))},n.context.target===e.C?fetch(\"https://zequencer.io/compile\",{method:\"POST\",headers:{\"Content-Type\":\"text/plain\"},body:o}).then((e=>Fe(void 0,void 0,void 0,(function*(){let t=yield e.arrayBuffer();yield WebAssembly.compile(t),r.port.postMessage({type:\"load-wasm\",body:t})})))):(Ye(n.context,r),r.port.postMessage({type:\"ready\"})),n.context.addWorklet(r),i||a({code:l,workletNode:r}),r};yield t.audioWorklet.addModule(u),i?a(m):m()})))),qe=(t,n)=>{let s=[],i=\"@beginMessage\",a=\"@endMessage\",r=n.code.indexOf(i),o=1;for(;r>-1;){let t=n.code.indexOf(a);if(-1===t)break;let l=n.code.slice(r+i.length,t);s.push(l),n.context.target===e.C?n.code=n.code.slice(0,r)+\"\"+o+++n.code.slice(t+a.length):n.code=n.code.slice(0,r)+\"this.messageKey\"+o+++n.code.slice(t+a.length),r=n.code.indexOf(i)}let l=\"\";o=1;for(let e of s)l+=`this.messageKey${o} = \"${e}\";\\n`,l+=`this.messageKeys[${o-1}] = \"${e}\";\\n`,o++;const{code:u,wasm:m}=We(n);return{code:`\\nclass ${t}Processor extends AudioWorkletProcessor {\\n\\n  async loadWASM(wasmBuffer) {\\nthis.port.postMessage({type: \"load wasm called\",body: \"yo\"});\\ntry {\\n    const wasmModule = await WebAssembly.compile(wasmBuffer);\\nthis.port.postMessage({type: \"compile completed\",body: \"yo\"});\\n    const importObject = {\\n    env: {\\n      memory: new WebAssembly.Memory({ initial: 256, maximum: 256 })\\n    },\\n GOT: {\\n    mem: {}\\n  }\\n   };\\n    \\nthis.port.postMessage({type: \"initing wasm\",body: \"yo\"});\\n    const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);\\n    this.wasmModule = wasmInstance;\\n    this.elapsed = 0;\\nthis.port.postMessage({type: \"init succesfful for wasm\",body: \"yo\"});\\n\\n    const BLOCK_SIZE = 128;\\n    this.inputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${n.numberOfInputs});\\n    this.input = new Float32Array(wasmInstance.exports.memory.buffer, this.inputPtr, BLOCK_SIZE * ${n.numberOfInputs});\\n    this.outputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${n.numberOfOutputs});\\n    this.output = new Float32Array(wasmInstance.exports.memory.buffer, this.outputPtr, BLOCK_SIZE * ${n.numberOfOutputs});\\n    this.port.postMessage({type: \"wasm-ready\"});\\n    this.wasmModule.exports.initSineTable();\\n} catch ( E) {\\nthis.port.postMessage({type: \"error-compiling\", data: \"yo\"});\\n}\\n  }\\n\\n  constructor() {\\n    super();\\n    this.ready = false;\\n    this.counter=0;\\n    this.messageCounter = 0;\\n    this.disposed = false;\\n    this.id = \"${t}\";\\n    this.events = [];\\n    this.messageKey = { type: '', subType: '' };\\n    this.messageQueue = new Map(); // Map of type/subType -> array of messages\\n    this.lastMessageTime = new Map(); // Map of type/subType -> last message time\\n    this.messageInterval = 100; // Minimum interval between messages for a given type/subType (in milliseconds)\\n\\n    ${Xe(\"    \",Je(n))}\\n\\n    this.messageKeys = [];\\n    ${l}\\n\\n    this.createSineTable();\\n    \\nthis.port.postMessage({type: \"ack\",body: \"yo\"});\\n\\n \\n    this.port.onmessage = (e) => {\\n       if (e.data.type === \"memory-set\") {\\n         let {idx, value} = e.data.body;\\n         if (this.wasmModule) {\\n           this.wasmModule.exports.setMemorySlot(idx, value);\\n         } else {\\n            this.memory[idx] = value;\\n         }\\n       } else if (e.data.type === \"load-wasm\") {\\n          this.loadWASM(e.data.body);\\n       } else if (e.data.type === \"schedule-set\") {\\n         let {idx, value, time} = e.data.body;\\n         this.events.push(e.data.body);\\n       } else if (e.data.type === \"init-memory\") {\\n         let {idx, data, time} = e.data.body;\\n         if (this.wasmModule) {\\n           for (let i=0; i < data.length; i++) {\\n             if (time) {\\n               this.events.push({idx: idx+i, value: data[i], time});\\n             } else {\\n               this.wasmModule.exports.setMemorySlot(idx + i, data[i]);\\n             }\\n           }\\n         } else {\\n           for (let i=0; i < data.length; i++) {\\n            this.memory.set(data, idx)\\n         }\\n}\\n       } else if (e.data.type === \"memory-get\") {\\n           if (this.wasmModule) {\\n             const memPointer = this.wasmModule.exports.get_memory();\\n             const memArray  = new Float32Array(this.wasmModule.exports.memory.buffer, memPointer , this.memory.length * 3);\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: memArray.slice(idx, idx+allocatedSize)\\n             });\\n             \\n           } else {\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: this.memory.slice(idx, idx+allocatedSize)\\n             });\\n           }\\n       } else if (e.data.type === \"dispose\") {\\n           this.disposed = true;\\n           this.memory = null;\\n       } else if (e.data.type === \"ready\") {\\n           this.ready = true;\\n       }\\n    }\\n  }\\n\\n  createSineTable() {\\n    const sineTableSize = 1024; // Choose a suitable size for the table, e.g., 4096 \\n    this.sineTable = new Float32Array(sineTableSize);\\n\\n    for (let i = 0; i < sineTableSize; i++) {\\n      this.sineTable[i] = Math.sin((2 * Math.PI * i) / sineTableSize);\\n    }\\n  }\\n\\n  toDelete = [];\\n  scheduleEvents(time=1) {\\n      this.toDelete.length = 0; \\n      for (let event of this.events) {\\n          let idx = event.idx;\\n          let value = event.value;\\n          event.time -= time;\\n          if (event.time <= 0) {\\n             if (this.wasmModule) {\\n                this.wasmModule.exports.setMemorySlot(idx, value);\\n             } else {\\n               this.memory[idx] = value;\\n             }\\n             this.toDelete.push(event);\\n          }\\n     }\\n     if (this.toDelete.length > 0) {\\n        for (let event of this.toDelete) {\\n           let index = this.events.indexOf(event);\\n           this.events.splice(index, 1);\\n        } \\n     }\\n  }\\n\\n   flushWASMMessages() {\\n      if (!this.wasmModule) {\\n         return;\\n      }\\n      let numMessages = this.wasmModule.exports.get_message_counter();\\n      const messageArrayPtr = this.wasmModule.exports.flush_messages();\\n      const messageArray = new Float32Array(this.wasmModule.exports.memory.buffer, messageArrayPtr, 1000 * 24);\\n      let messages = {\\n       };\\n      let heap32 = new Int32Array(this.wasmModule.exports.memory.buffer);\\n      let heapF64 = new Float64Array(this.wasmModule.exports.memory.buffer);\\nlet ids = [];\\nlet keys = [];\\n      for (let i=0; i < numMessages*24; i+=24) {\\n          let messagePtr = messageArrayPtr + i; \\n          let _type = heap32[messagePtr / 4] - 1;\\n          let subType = heapF64[(messagePtr + 8) / 8];\\n          let body = heapF64[(messagePtr + 16) / 8];\\n\\n         let type = this.messageKeys[_type];\\nids.push(_type);\\nkeys.push(type);\\n         if (!messages[type]) {\\n            messages[type] = {};\\n         }\\n         messages[type][subType] = body;\\n      }\\n      for (let type in messages) {\\n          for (let subType in messages[type]) {\\n             subType = parseFloat(subType);\\n             let msg = {type, subType, body: messages[type][subType]}; \\n             this.port.postMessage(msg);\\n          }\\n      }\\n      this.wasmModule.exports.empty_messages();\\n   }\\n\\n   queueMessage(type, subType, data) {\\n    // Get the subType map for the given type\\n    let subTypeMap = this.messageQueue.get(type);\\n    if (!subTypeMap) {\\n      subTypeMap = new Map();\\n      this.messageQueue.set(type, subTypeMap);\\n    }\\n\\n    // Add the message to the queue for the given type/subType\\n    let messageQueue = subTypeMap.get(subType);\\n    if (!messageQueue) {\\n      messageQueue = [];\\n      subTypeMap.set(subType, messageQueue);\\n    }\\n    messageQueue.push(data);\\n  }\\n\\n  checkMessages() {\\n    const now = performance.now();\\n\\n    // Iterate over the message queue and send messages if the rate limit has elapsed\\n    for (const [type, subTypeMap] of this.messageQueue.entries()) {\\n      for (const [subType, messages] of subTypeMap.entries()) {\\n        // Check if enough time has elapsed since the last message of this type/subType\\n        const key = type +  \":\" + subType;\\n        const lastMessageTime = this.lastMessageTime.get(key) || 0;\\n        if (now - lastMessageTime >= this.messageInterval) {\\n          // Send the next message in the queue\\n          const data = messages.shift();\\n          this.port.postMessage({type, subType, body: data});\\n";
    }
}
