
pragma solidity ^0.8.20;

contract CompressedLibrary2 {
    string public data;

    constructor() {
        data = "ize of one block of samples\\n\\n#define MEM_SIZE ${t} // Define this based on your needs\\n#define SINE_TABLE_SIZE 1024\\n#define MAX_MESSAGES 10000\\n\\ndouble memory[MEM_SIZE]; // Your memory buffer\\ndouble  sineTable[SINE_TABLE_SIZE]; // Your memory buffer\\n\\nint elapsed = 0;\\n\\nstruct Message {\\n   int type;\\n   double subType;\\n   double body;\\n};\\n\\nint message_counter = 0;\\nstruct Message messages[MAX_MESSAGES];\\n\\nvoid new_message(int type, float subType, float body) {\\n   messages[message_counter].type = type;\\n   messages[message_counter].subType = subType;\\n   messages[message_counter].body = body;\\n   message_counter = (message_counter + 1);\\n   if (message_counter >= MAX_MESSAGES) {\\n     message_counter = 0;\\n   }\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nint get_message_counter() {\\n  return message_counter;\\n}\\n\\n// Get a pointer to the messages array\\nstruct Message* EMSCRIPTEN_KEEPALIVE flush_messages() {\\n   return messages;\\n}\\n\\n\\n// Get a pointer to the messages array\\ndouble * EMSCRIPTEN_KEEPALIVE get_memory() {\\n        return memory;\\n    }\\n\\n    EMSCRIPTEN_KEEPALIVE\\n    void empty_messages() {\\n        //message_counter = 0;\\n    }\\n\\n    \\n    double random_double() {\\n        return rand() / (float)RAND_MAX;\\n    }\\n\\n${n?\"\\n    float matrix4x4SumResult[4];\\n\\n    float* matrix4x4Sum(int inputIdx, int matrixIdx, int size) {\\n       v128_t sum = wasm_f32x4_splat(0.0f); // initialize an SIMD vector with zeros\\n       int i=0;\\n       for (i=0; i < 4; i++) {\\n          v128_t weights = wasm_f32x4_splat(memory[inputIdx+i]); \\n          int idx = matrixIdx + i * size;\\n          v128_t row = wasm_v128_load(&memory[idx]);\\n          v128_t prod = wasm_f32x4_mul(row, weights);\\n          sum = wasm_f32x4_add(sum, prod);\\n       }\\n       wasm_v128_store(matrix4x4SumResult, sum); \\n       return matrix4x4SumResult;\\n    }\\n\":\"\"}\\n/*\\n*/\\n\\n    EMSCRIPTEN_KEEPALIVE\\n    void* my_malloc(size_t size) {\\n        return malloc(size);\\n    }\\n\\n    EMSCRIPTEN_KEEPALIVE\\n    void initSineTable() {\\n        for (int i = 0; i < SINE_TABLE_SIZE; i++) {\\n            sineTable[i] = sin((2 * M_PI * i) / SINE_TABLE_SIZE);\\n        }\\n    }\\n\\n/*\\n    void init(float * mem) {\\n        for (int i = 0; i < MEM_SIZE; i++) {\\n            memory[i] = mem[i];\\n        }\\n    }\\n*/\\n\\n    EMSCRIPTEN_KEEPALIVE\\n    void setMemorySlot(int idx, double val) {\\n        memory[idx] = val;\\n    }\\n\\n/*\\n    void setMemoryRegion(int idx, double* val, int size) {\\n        for (int i = 0; i < size; i++) {\\n            memory[idx + i] = val[i];\\n        }\\n    }\\n*/\\n\\n${et(e.functions,e.context.target,e.context.varKeyword)}\\n\\n    EMSCRIPTEN_KEEPALIVE\\n    void process(float * inputs, float * outputs) {\\n        for (int j = 0; j < BLOCK_SIZE; j++) {\\n      ${Ue(e)}\\n      ${Qe(e)}\\n      ${Ze(e)}\\n      ${Xe(\"      \",e.code)}\\n      ${Ge(e)}\\n            elapsed++;\\n        }\\n    }\\n\\n    `;return n&&(s=Re(s,\"double\",\"float\")),s})(t);return{code:`\\nprocess(inputs, outputs, parameters) {\\n    if (this.disposed || !this.ready) {\\n      return true;\\n    }\\n    const BLOCK_SIZE = 128;\\n    let inputChannel = inputs[0];\\n    let outputChannel = outputs[0];\\n\\n    if (this.messageCounter % 10 === 0) {\\n      this.flushWASMMessages();\\n    }\\n    this.messageCounter++;\\n\\n    this.scheduleEvents(128);\\n\\n    for (let i = 0; i < 1; i ++) {\\n      if (!this.wasmModule) {\\n         return true;\\n      } \\n      for (let j = 0; j < ${t.numberOfInputs}; j++) {\\n        const inputChannel = inputs[0][j];\\n        // Copy input samples to input buffer\\n        if (inputChannel) {\\n          this.input.set(inputChannel, j * 128);\\n        }\\n      } \\n\\n      // Process samples\\n      this.wasmModule.exports.process(this.inputPtr, this.outputPtr);\\n\\n      // Copy output buffer to output channel\\n      for (let j=0; j < ${t.numberOfOutputs}; j++) {\\n     \\n         let arr = this.output.slice(j*128, (j+1)*128);\\nif (j === 1) {\\n}\\n         outputs[0][j].set(arr, 0);\\n      }\\n    }\\n    return true;\\n}\\n`,wasm:e}}return{code:`\\n${et(t.functions,t.context.target,t.context.varKeyword)}\\nprocess(inputs, outputs) {\\n    if (this.disposed || !this.ready) {\\n      return true;\\n    }\\n  let memory = this.memory;\\n \\n\\n  // note: we need to go thru each output channel for each sample\\n  // instead of how we are doing it here... or else the histories\\n  // will get all messed up.\\n  // actually, really the whole channels concept should be removed...\\n  for (let j=0; j < outputs[0][0].length; j++) {\\n      let elapsed = this.elapsed++;\\n      this.messageCounter++;\\n      this.scheduleEvents();\\n      ${Ue(t)}\\n      ${Qe(t)}\\n      ${Ze(t)}\\n      ${Xe(\"      \",t.code)}\\n      ${Ge(t)}\\n    }\\n  return true;\\n}\\n`,wasm:\"\"}},Ze=e=>He(e.context.varKeyword,e.histories,!0),He=(e,t,n=!0)=>{let s=\"\",i=[];for(let a of t)n&&a.includes(\"*i\")||(a=a.replace(\"let\",e)+\";\",i.includes(a)||s.includes(a)||(s+=Xe(\"   \",a)),i.push(a));return s},Qe=e=>{let t=\"\";for(let n=0;n<e.numberOfOutputs;n++)t+=`${e.context.varKeyword} output${n} = 0;`;return t},Ue=t=>{let n=\"\";for(let s=0;s<t.numberOfInputs;s++)t.context.target===e.C?n+=`${t.context.varKeyword} in${s} = inputs[j + ${128*s}];\\n`:n+=`${t.context.varKeyword} in${s} = inputs[0][${s}]  ? inputs[0][${s}][j] : 0;\\n`;return n},Ge=t=>{let n=\"\";for(let s=0;s<t.numberOfOutputs;s++)t.context.target===e.C?n+=`\\noutputs[j + ${128*s}] = output${s};\\n`:n+=`\\n            outputs[0][${s}][j] = output${s};\\n            `;return n},Je=e=>`\\n            this.memory = new Float64Array(${e.context.memory.size});\\n            `,Xe=(e,t)=>t.split(\"\\n\").map((t=>e+t)).join(\"\\n\"),Ye=(e,t)=>{for(let n of e.memory.blocksInUse)void 0!==n.initData&&(void 0===n._idx?n.idx:n._idx,t.port.postMessage({type:\"init-memory\",body:{idx:void 0===n._idx?n.idx:n._idx,data:n.initData}}))},et=(t,n,s)=>{let i=\"\";for(let a of t){let t=a.name,r=a.code,o=tt(a.functionArguments);o.sort(((e,t)=>e.num-t.num));let l=o.map((t=>(n===e.C?s+\" \":\"\")+t.name)).join(\",\"),u=a.histories,m=(e.C,n===e.C?\"\":\"let memory = this.memory;\"),d=He(\"let\",u,!1);for(let e of u)r=Re(r,e,\"\");let $=`\\n${n===e.C?\"\":\"let elapsed = this.elapsed\"}\\n${m}\\n${d}\\n${r}\\nreturn ${a.variable};\\n    `,h=n===e.C?s+\"* \":\"\",p=n===e.C?\"int \":\"\";i+=`\\n ${n===e.C?`${s} ${t}Array[16];`:`${t}Array = new Float32Array(16)`}\\n\\n${h} ${t}(${p} invocation, ${l}) {\\n${Xe(\"    \",$)}\\n}\\n            `}return i},tt=e=>{let t=[];for(let n of e)t.some((e=>e.num===n.num))||t.push(n);return t},nt=(e,t)=>o((n=>{let[s,i]=n.useVariables(\"i\",\"sum\"),a=\"number\"==typeof e.min&&\"number\"==typeof e.max?new le(s,e,n):n,r=n.gen(e.min),o=n.gen(e.max),l=it(s),u=t(l)(a),m=Array.from(new Set(u.histories));m=m.map((e=>Re(e,\"let\",n.varKeyword)+\";\"));let d=Array.from(new Set(u.outerHistories));d=d.map((e=>Re(e,\"let\",n.varKeyword)+\";\"));let $=`\\n${Xe(\"    \",d.join(\"\"))}\\n${n.varKeyword} ${i} = 0;\\nfor (${n.intKeyword} ${s}=${r.variable}; ${s} < ${o.variable}; ${s}++ ) {\\n${Xe(\"    \",m.join(\"\\n\"))}\\n${Xe(\"    \",u.code)}\\n    ${i} += ${u.variable};\\n}\\n`;return n.emit($,i)})),st=(e,t,n)=>o((s=>{let[i]=s.useVariables(\"sum\"),a=\"number\"==typeof e.min&&\"number\"==typeof e.max?new le(n,e,s):s;console.log(\"creating loop context=\",a);let r=s.gen(e.min),o=s.gen(e.max),l=t(a),u=Array.from(new Set(l.histories));u=u.map((e=>Re(e,\"let\",s.varKeyword)+\";\"));let m=Array.from(new Set(l.outerHistories)).filter((e=>!s.historiesEmitted.includes(e)));s.historiesEmitted=[...s.historiesEmitted,...m],m=m.map((e=>Re(e,\"let\",s.varKeyword)+\";\"));let d=`\\n${Xe(\"    \",m.join(\"\"))}\\n${s.varKeyword} ${i} = 0;\\nfor (${s.intKeyword} ${n}=${r.variable}; ${n} < ${o.variable}; ${n}++ ) {\\n${Xe(\"    \",u.join(\"\"))}\\n${Xe(\"    \",l.code)}\\n    ${i} += ${l.variable};\\n}\\n`;return s.emit(d,i)})),it=e=>t=>{let[n]=t.useVariables(\"loopIdx\"),s=`${t.context?t.context.intKeyword:t.intKeyword} ${n} = ${e};`,i=t.emit(s,n);return i.isLoopDependent=!0,i},at=(t,n,s)=>i=>{let a=i.gen(s),r=i.gen(n),[o]=i.useVariables(\"message\"),l=\"\";return i.target===e.C?l+=`\\nnew_message(@beginMessage${t}@endMessage, ${r.variable}, ${a.variable});\\n`:l+=`\\nif (this.messageCounter % 2000 === 0) {\\nthis.port.postMessage({type: @beginMessage${t}@endMessage, subType: ${r.variable}, body: ${a.variable}});\\n}\\n`,l+=`\\n${i.varKeyword} ${o} = ${a.variable};\\n\\n`,i.emit(l,o,r,a)},rt=(e,t,n)=>o((s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`${s.varKeyword} ${o} = ${i.variable} ? ${a.variable} : ${r.variable};`;return s.emit(l,o,i,a,r)})),ot=(e,t,n)=>s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`let ${o} = ${i.variable} ? ${a.variable} : ${r.variable}`;return s.emit(l,o,i,r)},lt=(e,t,n)=>s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`let ${o} = ${i.variable} ? ${a.variable} : ${r.code}`;return s.emit(l,o,i,a)},ut=m(\"Math.random\",\"random\"),mt=(e,t,n,s,i)=>o((a=>{let r=a.gen(e),o=a.gen(t),l=a.gen(s),u=a.gen(n),m=a.gen(i),d=a.idx++,$=`scaleVal${d}`,h=`range1${d}`,p=`range2${d}`,c=\"number\"==typeof t&&\"number\"==typeof n?n-t:`${u.variable} - ${o.variable}`,b=\"number\"==typeof s&&\"number\"==typeof i?i-s:`${m.variable} - ${l.variable}`,y=`${a.varKeyword} ${h} = ${c};\\n${a.varKeyword} ${p} = ${b};\\n${a.varKeyword} ${$} = ${h} == 0 ? ${l.variable} : \\n    (((${r.variable} - ${o.variable}) * ${p}) / ${h}) + ${l.variable};`;return a.emit(y,$,r,o,u,l,m)})),dt=(...e)=>t=>{let n=\"\\n/** SEQ START **/\",s=\"\",i=[],a=[],r=[],o=[],l=[],u=0;for(let m of e){if((new Date).getTime(),\"function\"!=typeof m)continue;let e=m(t);l=[...l,...e.params],n+=\" \"+e.code+\";\",s=e.variable,t.emittedVariables[s]=!0,e.histories&&(i=[...i,...e.histories]),e.outerHistories&&(a=[...a,...e.outerHistories]),e.functions&&(r=[...r,...e.functions]),e.functionArguments&&(o=[...o,...e.functionArguments]),(new Date).getTime(),e.outputs>u&&(u=e.outputs)}return n+=\"/** SEQ END **/\",{functions:r,functionArguments:o,outputs:u,params:l,code:n,variable:s,histories:i,outerHistories:a}};class $t{constructor(e,t,n){this.connections=[],this.isEntryPoint=n,this.material=e,this.web=t,console.log(\"COMPONENT \",n?\"A\":\"B\",this),console.log(\"WEB.size = %s maxNeights=%s\",t.size,t.maxNeighbors),this.neighbors=Ve(t.size*t.maxNeighbors,1,t.neighbors,!0,\"none\"),this.coeffs=t.data,this.dampening=t.dampeningData,this.nt2=q(P(2,-8),P(2,-13),e.release),this.u=Ve(t.size,3,void 0,!0,\"none\"),this.currentChannel=accum(1,0,{min:0,max:2,exclusive:!1}),this.prevChannel=p(this.currentChannel,1),this.u_center=ze(this.u,0,this.prevChannel),this.tension=q(P(2,-12),P(2,-5),.0999151),this.p0=q(11044095e-20,.01,e.pitch),this.p_eff=R(.47,d(this.p0,P(b(this.u_center,this.tension,1),2)))}get size(){return this.web.size}gen(e){return this.isEntryPoint&&(this.excitementEnergy=e),dt(this.currentChannel,this.prevChannel,e,this.nt2,this.u_center,this.tension,this.p0,this.material.couplingCoefficient,this.p_eff,b(y(200,this.size),nt({min:0,max:this.size},(t=>this.nodeDisplacement(e,t)))))}nodeDisplacement(e,t){let n=ze(this.u,t,this.prevChannel),s=this.calculateNeighborsEnergy(t,n,e),i=b(e,this.lerpExcitementEnergy(t,this.material.x,this.material.y)),a=ze(this.u,t,p(this.currentChannel,2)),r=q(P(2,-8),P(2,-13),b(ze(this.dampening,t,0),this.material.release)),o=y(d(b(2,n),b(this.p_eff,d(s,b(1,i),b(-4,n))),b(-1,p(1,r),a)),d(1,r));return dt(Oe(this.u,t,this.currentChannel,y(L(b(.6366197723675814,o)),.6366197723675814)),o)}lerpExcitementEnergy(e,t,n){let s=b(e,2),i=ze(this.web.pointsData,s,0),a=ze(this.web.pointsData,d(s,1),0),r=D(d(P(p(i,t),2),P(p(a,n),2))),o=Z(p(1,y(r,80)),0,1);return N(y((e=>b(-1,e))(P(r,2)),b(2,P(y(80,2),2)))),o}calculateNeighborsEnergy(e,t,n){let s=R(20,this.material.noise),i=b(mt(ut(),0,1,-1,1),s);this.connections[0]&&this.connections[0].component.isEntryPoint&&(n=this.connections[0].component.excitementEnergy);let a=b(.5,d(b(q(P(n,.5),t,1),i),this.sumNeighbors(e,this.prevChannel,this.web.maxNeighbors,this.u,this.neighbors,this.coeffs)));for(let n of this.connections){let{component:s,neighbors:i}=n,r=ze(i,e,0),o=_(r,-1),l=ze(s.u,r,s.prevChannel),u=p(l,t),m=rt(o,b(u,this.material.couplingCoefficient),0);a=d(a,m)}return a}sumNeighbors(e,t=this.prevChannel,n,s=this.u,i=this.neighbors,a=this.coeffs){return nt({min:0,max:n+1},(r=>{let o=ze(i,d(b(n,e),r),0),l=ze(a,o,e);return dt(rt(_(o,-1),b(rt(K(l,-1),b(-1,ze(s,e,t)),ze(s,o,t)),l),0))}))}connect(e,t){let n=Ve(e.size*t.maxNeighbors,1,t.neighbors);return Ve(e.size,e.size,t.coeffs),this.connections.push({component:e,neighbors:n}),this}bidirectionalConnect(e){let t,n;if(e.size<this.size){let[s,i]=ht(e,this);t=s,n=i}else{let[s,i]=ht(this,e);t=i,n=s}let s=Ve(t.length,1,t,!0,\"none\"),i=Ve(n.length,1,n,!0,\"none\");this.connections.push({component:e,neighbors:i}),e.connections.push({component:this,neighbors:s})}}const ht=(e,t)=>{let n=new Float32Array(e.size);for(let s=0;s<e.size;s++)n[s]=t.size-1-s;let s=new Float32Array(t.size),i=t.size-e.size;for(let e=0;e<t.size;e++)s[e]=e<i?-1:t.size-e-1;return[n,s]},pt=(e,t=\"hello\")=>{let n=se(e,{inline:!1,name:t}),s=n();return s.set=(e,t)=>{n.value(e,t)},s},ct=t=>o((n=>{let[s]=n.useVariables(\"t60\"),i=n.gen(t),a=n.target===e.C?u[\"Math.exp\"]:\"Math.exp\",r=`\\n${n.varKeyword} ${s} = ${a}(-6.907755278921 / ${i.variable});\\n`;return n.emit(r,s,i)})),bt=(e=44100)=>{let t=se(),n=t(b(t(),ct(e)));return n.trigger=()=>{t.value(1)},n},yt=(e,t=44100)=>{let n=se();return n(q(e,n(),ct(t)))},ft=(e,t=.5)=>o((n=>rt(f(e,t),mt(e,0,t,0,1),mt(e,t,1,1,0))(n))),gt=e=>mt(V(b(Math.PI,e)),1,-1,0,1),vt=e=>o((t=>{let n=t.gen(e),[s]=t.useVariables(\"ms\"),i=`${t.varKeyword} ${s} = 1000.0*${n.variable}/${t.sampleRate};`;return t.emit(i,s,n)})),xt=e=>o((t=>{let n=t.gen(e),[s]=t.useVariables(\"samps\"),i=`${t.varKeyword} ${s} = (${n.variable}/1000)*${t.sampleRate};`;return t.emit(i,s,n)})),wt=e=>{let t=se();return p(e,t(q(e,t(),.999)))},Mt=()=>o((e=>{let[t]=e.useVariables(\"elapsed\"),n=`${e.varKeyword} ${t} = elapsed;`;return e.emit(n,t)})),Kt=t=>o((n=>{let s=n.gen(t),[i]=n.useVariables(\"fixed\"),a=n.target===e.C?\"isnan\":\"isNaN\",r=`${n.varKeyword} ${i} = ${a}(${s.variable}) ? 0.0 : ${s.variable};`;return n.emit(r,i,s)}));return n})()));;window.ZEN_LIB = zen; Object.keys(ZEN_LIB).forEach(key => window[key] = ZEN_LIB[key]);";
    }

    function getData() public view returns  (string memory) {
        return data;
    }
}
