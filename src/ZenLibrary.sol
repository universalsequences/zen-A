




// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.2 <0.9.0;

contract ZenLibrary  {

    string public lib;
    constructor() {
        lib = "!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.zen=t():e.zen=t()}(this,(()=>(()=>{\"use strict\";var e={d:(t,n)=>{for(var s in n)e.o(n,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:n[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};e.r(t),e.d(t,{Component:()=>De,Context:()=>h,LoopContext:()=>d,abs:()=>R,accum:()=>accum,add:()=>E,adsr:()=>Ue,and:()=>P,atan:()=>G,breakIf:()=>he,cKeywords:()=>M,ceil:()=>B,change:()=>ye,clamp:()=>ie,cos:()=>Z,createWorklet:()=>Me,cycle:()=>cycle,data:()=>de,dcblock:()=>Ye,decay:()=>We,decayTrig:()=>He,delay:()=>fe,delta:()=>$e,div:()=>K,elapsed:()=>et,emitCode:()=>p,emitHistory:()=>o,emitOuterHistory:()=>l,emitOuterLoops:()=>$,emitParams:()=>u,eq:()=>j,exp:()=>X,exp2:()=>le,fixnan:()=>tt,float:()=>y,floor:()=>D,func:()=>w,genArg:()=>g,generateStructure:()=>Be,gt:()=>A,gte:()=>O,history:()=>r,input:()=>b,latch:()=>ge,log10:()=>Q,log2:()=>H,lt:()=>z,lte:()=>V,max:()=>ee,min:()=>Y,mix:()=>ne,mod:()=>N,mstosamps:()=>Je,mult:()=>T,neq:()=>L,noise:()=>Le,not_sub:()=>re,op:()=>x,or:()=>k,param:()=>qe,peek:()=>pe,phasor:()=>me,poke:()=>ce,pow:()=>U,print:()=>Fe,rampToTrig:()=>be,rawSumLoop:()=>Ae,reciprical:()=>ae,round:()=>oe,s:()=>Re,sampstoms:()=>Xe,scale:()=>Ne,shiftLeft:()=>_,shiftRight:()=>S,sign:()=>te,sin:()=>q,sine:()=>Ge,sqrt:()=>J,sub:()=>I,sumLoop:()=>Ve,t60:()=>Ze,tan:()=>F,tanh:()=>W,triangle:()=>Qe,variable:()=>Oe,wrap:()=>se,xor:()=>C,zen:()=>f,zswitch:()=>Pe,zswitch_inline_else:()=>je,zswitch_inline_then:()=>ke});class n{}class s extends n{constructor(e,t,n,s,i){super(),this.context=e,this.__idx=-1,this._size=n,this.idx=t,this.size=n,this.allocatedSize=s,this.initData=i}set idx(e){this.__idx=e}get idx(){return this.__idx}set size(e){this._size=e}get size(){return this._size}respond(e){this.responseCallback(e),this.waitingForResponse=void 0}get(){return this.context.postMessage({type:\"memory-get\",body:{idx:this.idx,allocatedSize:this.allocatedSize}}),this.waitingForResponse=\"memory-get\",new Promise((e=>{this.responseCallback=e}))}}class i extends s{constructor(e,t,n,s){super(e,t,n,s),this.context=e,this._idx=t,this._size=n,this.allocatedSize=s,this.channels=0,this.length=0}get idx(){return`${this._idx} + ${this.allocatedSize}*${this.context.loopIdx}`}set idx(e){this._idx=e}get size(){return this._size*this.context.loopSize}set size(e){this._size=e}}class a{constructor(e,t){this.size=t,this.context=e,this.references=0,this.blocksInUse=[],this.freeList=[new s(e,0,t,0)]}alloc(e){for(let t=0;t<this.freeList.length;t++){let n=this.freeList[t];if(e<=n.size)return n=this.useBlock(n,e,t),n.allocatedSize=e,this.blocksInUse.push(n),n}return this.increaseHeapSize(),this.alloc(e)}increaseHeapSize(){this.size*=2;let e=this.freeList[this.freeList.length-1];e.size=this.size-e.allocatedSize}useBlock(e,t,n){return e.size==t?this.freeList.splice(n,1):this.freeList.splice(n,1,new s(this.context,e.idx+t,e.size-t,t)),this.references++,e}free(e){this.freeList.push(e),this.references--,0===this.references&&(this.freeList[0].idx=0)}}const r=(e,t,n)=>{let s,i,a,r,m=[],h=(d,c)=>$=>{let b=$;if(t&&t.name)for(;\"context\"in b;)b=b.context;$=b;let f=\"number\"==typeof d?y(d)(b):d?d(b):void 0,g=void 0===c?b.gen(y(0)):b.gen(c),v=a!==$;a=$,(void 0===s||v)&&(s=a.alloc(1),i=a.useVariables(n||\"historyVal\")[0],m=m.filter((e=>!e.context.disposed)),m.push({context:a,block:s})),44794===s._idx&&console.log(\"BLOCK IDX context=\",a,s);let x=s.idx,M=`${a.varKeyword} ${i} = memory[${x}]\\n`,w=\"\",E=i;if(f){let[e]=a.useVariables(\"histVal\");w=`\\nif (${g.variable} > 0) {\\n  memory[${x}] = 0;\\n}\\nmemory[${x}] = ${f.variable};\\n`,t&&t.inline||(w+=`${a.varKeyword} ${e} = ${i};\\n`),t&&t.inline&&(e=w,w=\"\"),E=e,w=p(a,w,E,f,g)}let _=f?o(f,g):[],S=f?l(f,g):[];void 0!==e&&(s.initData=new Float32Array([e])),void 0!==r&&(s.initData=new Float32Array([r]));let I=f?u(f):[];return t&&t.name&&(I=[h,...I]),M.includes(\"*\")||(S=[M,...S]),{code:w,variable:E,histories:[M,..._],outerHistories:S,params:I}};return t&&(h.paramName=t.name),h.value=(e,t)=>{if(void 0!==a){for(let{context:n,block:s}of m){let i=void 0!==t?\"schedule-set\":\"memory-set\",a={idx:s.idx,value:e,time:t};n.postMessage({type:i,body:a})}r=e}},h},o=(...e)=>Array.from(new Set(e.flatMap((e=>e.histories)))),l=(...e)=>Array.from(new Set(e.flatMap((e=>e.outerHistories||[])))),u=(...e)=>Array.from(new Set(e.flatMap((e=>e.params))));var m;!function(e){e[e.Javascript=0]=\"Javascript\",e[e.C=1]=\"C\"}(m||(m={}));class h{constructor(e=m.Javascript){this.memory=new a(this,4194304),this.idx=0,this.histories=0,this.historiesEmitted=[],this.numberOfInputs=1,this.sampleRate=44100,this.emittedVariables={},this.worklets=[],this.disposed=!1,this.target=e}get varKeyword(){return this.target===m.C?\"float\":\"let\"}get intKeyword(){return this.target===m.C?\"int\":\"let\"}alloc(e){return this.memory.alloc(e)}addWorklet(e){this.worklets.push(e)}postMessage(e){this.worklets.forEach((t=>t.port.postMessage(e)))}onMessage(e){for(let t of this.memory.blocksInUse)t.waitingForResponse===e.type&&t.respond(e.body)}isVariableEmitted(e){return!0===this.emittedVariables[e]}useVariables(...e){let t=this.idx++;return e.map((e=>`${e}${t}`))}gen(e){return void 0===e&&(e=0),\"number\"==typeof e?y(e)(this):\"function\"==typeof e?e(this):y(0)(this)}emit(e,t,...n){let s=o(...n),i=l(...n),a=Array.from(new Set([...i,...s.filter((e=>!e.includes(\"*\")&&!e.includes(\"loopIdx\")))]));\"context\"in this&&(s=s.filter((e=>e.includes(\"*\"))));let r=u(...n),m={code:p(this,e,t,...n),variable:t,histories:s,outerHistories:a,params:r,context:this},h=n.filter((e=>void 0!==e.inputs)).map((e=>e.inputs));return h.length>0&&(m.inputs=Math.max(...h)),m}input(e){return e>this.numberOfInputs&&(this.numberOfInputs=e),\"in\"+e}}class d extends h{constructor(e,t,n){super(),this.context=n,this.loopIdx=e,this.loopSize=t.max-t.min,this.memory=n.memory,this.idx=n.idx,this.histories=n.histories,this.numberOfInputs=n.numberOfInputs,this.sampleRate=n.sampleRate,this.emittedVariables=Object.assign({},n.emittedVariables),this.worklets=n.worklets,this.target=n.target}useVariables(...e){return this.context.useVariables(...e)}isVariableEmitted(e){return!0===this.emittedVariables[e]||this.context.isVariableEmitted(e)}alloc(e){let t=this.memory.alloc(e*this.loopSize),n=this.memory.blocksInUse.indexOf(t),s=(this.context,new i(this,t.idx,t.size,e));return this.memory.blocksInUse[n]=s,s}}const p=(e,t,n,...s)=>{let i=\"\";if(t.trim().startsWith(\"let\")&&e.isVariableEmitted(n))return n;e.emittedVariables[n]=!0;for(let t of s)c(t)&&(i+=t.code,e.emittedVariables[t.variable]=!0);return i+\"\\n\"+t},c=e=>e.code!==e.variable,$=(...e)=>Array.from(new Set(e.flatMap((e=>e.outerLoops||[])))),y=e=>{let t=e.toString();return e-Math.floor(e)==0&&(t+=\".0\"),()=>({code:t,variable:t,histories:[],params:[]})},b=(e=0)=>t=>{let n=t.input(e);return{code:n,variable:n,histories:[],inputs:e,params:[]}},f=(...e)=>{let t=new h(m.Javascript),n=\"\",s=\"\",i=1,a=1,r=[],o=[];for(let l of e){let e=l(t);n+=\" \"+e.code,s=e.variable,o=[...o,...e.params],e.histories&&(r=[...r,...e.histories]),void 0!==e.outputs&&e.outputs+1>i&&(i=e.outputs+1),void 0!==e.inputs&&e.inputs>a&&(a=e.inputs)}return 1===i&&(n+=`\\noutput0 = ${s};\\n`),{code:n,context:t,variable:s,histories:r,numberOfInputs:a+1,numberOfOutputs:i,params:o}},g=(e,t)=>\"number\"==typeof e?y(e)(t):e(t),v=e=>{let t,n;return s=>{if(void 0!==t){if(n===s)return s.isVariableEmitted(t.variable)?Object.assign(Object.assign({},t),{code:t.variable}):t;if(!n.context)return s.isVariableEmitted(t.variable)?Object.assign(Object.assign({},t),{code:t.variable}):t}return n=s,t=e(s),t}},accum=(e,t=0,n)=>{let s;return v((i=>{s=i.alloc(1);let a=g(e,i),r=g(t,i),[o]=i.useVariables(\"accum\");void 0!==n.init&&(s.initData=new Float32Array([n.init]));let l=\"number\"==typeof t&&0===t?\"\":`if (${r.variable} > 0) ${o} = ${n.min};`,u=`${n.max-n.min} + ${a.variable}`,m=!(void 0!==n.exclusive&&!n.exclusive),h=!0===m?\">=\":\">\",d=`${i.varKeyword} ${o} = memory[${s.idx}];\\n${l}\\nmemory[${s.idx}] = ${o} + ${a.variable};\\nif (memory[${s.idx}] ${h} ${n.max}) memory[${s.idx}] -= ${m?n.max-n.min:u};\\n`;return i.emit(d,o,a,r)}))},x=(e,t,n,s)=>(...i)=>v((a=>{let r=i.map((e=>a.gen(e))),[o]=a.useVariables(t+\"Val\"),l=`${a.varKeyword} ${o} = ${r.map((e=>e.variable)).join(\" \"+e+\" \")};`;if(\"%\"===e&&a.target===m.C&&(l=`${a.varKeyword} ${o} = fmod(${r[0].variable}, ${r[1].variable});`),\"^\"===e&&a.target===m.C&&(l=`${a.varKeyword} ${o} = ((int)${r[0].variable})^((int) ${r[1].variable});`),\"/\"===e&&(l=`${a.varKeyword} ${o} = ${r[1].variable} == 0.0 ? 0.0 : ${r.map((e=>e.variable)).join(\" \"+e+\" \")};`),i.every((e=>\"number\"==typeof e))&&void 0!==n){let e=i.map((e=>e)).reduce(n,void 0===s?i[0]:s);return l=`${a.varKeyword} ${o} = ${e};`,a.emit(l,o)}return a.emit(l,o,...r)})),M={\"Math.abs\":\"fabs\",\"Math.random\":\"random_double\",\"Math.floor\":\"floor\",\"Math.round\":\"round\",\"Math.ceil\":\"ceil\",\"Math.sin\":\"sin\",\"Math.tan\":\"tan\",\"Math.cos\":\"cos\",\"Math.tanh\":\"tanh\",\"Math.log2\":\"(1.0f / log(2)) * log\",\"Math.log10\":\"log10\",\"Math.pow\":\"pow\",\"Math.atan\":\"atan\",\"Math.exp\":\"exp\",\"Math.sqrt\":\"sqrt\",\"Math.min\":\"fmin\",\"Math.max\":\"fmax\"},w=(e,t,n)=>(...s)=>i=>{let a=s.map((e=>i.gen(e))),[r]=i.useVariables(`${t}Val`),o=i.target===m.C?M[e]:e,l=s.length>0&&s.every((e=>\"number\"==typeof e))?`${i.varKeyword} ${r} = ${n(...s)};`:`${i.varKeyword} ${r} = ${o}(${a.map((e=>e.variable)).join(\",\")});`;return i.emit(l,r,...a)},E=x(\"+\",\"add\",((e,t)=>e+t),0),_=x(\"<<\",\"shiftLeft\",((e,t)=>e<<t),0),S=x(\">>\",\"shiftRight\",((e,t)=>e>>t),0),I=x(\"-\",\"sub\",((e,t)=>e-t)),C=x(\"^\",\"xor\",((e,t)=>e^t)),T=x(\"*\",\"mult\",((e,t)=>e*t),1),K=x(\"/\",\"div\",((e,t)=>e/t)),z=x(\"<\",\"lt\"),V=x(\"<=\",\"lte\"),A=x(\">\",\"gt\"),O=x(\">=\",\"gte\"),P=x(\"&&\",\"and\"),k=x(\"||\",\"or\"),j=x(\"==\",\"eq\"),L=x(\"!=\",\"neq\"),N=x(\"%\",\"mod\",((e,t)=>e%t)),R=w(\"Math.abs\",\"abs\",Math.abs),D=w(\"Math.floor\",\"floor\",Math.floor),B=w(\"Math.ceil\",\"ceil\",Math.ceil),q=w(\"Math.sin\",\"sin\",Math.sin),F=w(\"Math.tan\",\"tan\",Math.tan),Z=w(\"Math.cos\",\"cos\",Math.cos),W=w(\"Math.tanh\",\"tanh\",Math.tanh),H=w(\"Math.log2\",\"log2\",Math.log2),Q=w(\"Math.log10\",\"log10\",Math.log10),U=w(\"Math.pow\",\"pow\",Math.pow),G=w(\"Math.atan\",\"atan\",Math.atan),X=w(\"Math.exp\",\"exp\",Math.exp),J=w(\"Math.sqrt\",\"sqrt\",Math.sqrt),Y=w(\"Math.min\",\"min\",Math.min),ee=w(\"Math.max\",\"max\",Math.max),te=e=>I(z(0,e),z(e,0)),ne=(e,t,n)=>E(T(t,n),T(e,I(y(1),n))),se=(e,t,n)=>v((s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),o=`(${r.variable} - ${a.variable})`,[l]=s.useVariables(\"wrapVal\"),u=s.target===m.C?`fmod(${l} - ${a.variable}, ${o})`:`(${l} - ${a.variable}) % ${o}`,h=s.target===m.C?M[\"Math.floor\"]:\"Math.floor\",d=`\\n${s.varKeyword} ${l} = ${i.variable};\\nif( ${l} < ${a.variable}) ${l} += ${o} * (${h}((${a.variable} - ${l} / ${o})) + 1);\\n${l}=  ${a.variable} + ${u}; //((${l} % ${o}) + ${o})%${o};`;return s.emit(d,l,i,a,r)})),ie=(e,t,n)=>v((s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"clampVal\"),l=`\\n${s.varKeyword} ${o} = ${i.variable};\\nif( ${o} < ${a.variable}) ${o} = ${a.variable};\\nelse if(${o} > ${r.variable}) ${o} = ${r.variable};`;return s.emit(l,o,i,a,r)})),ae=e=>v((t=>{let n=t.gen(e),[s]=t.useVariables(\"recipricalValue\"),i=`${t.varKeyword} ${s} = ${n.variable} == 0 ? 0 : 1.0/${n.variable};`;return t.emit(i,s,n)})),re=(e,t)=>v((n=>{let s=n.gen(e),i=t?n.gen(t):y(1)(n),[a]=n.useVariables(\"notSubValue\"),r=`${n.varKeyword} ${a} = ${i.variable} - ${s.variable};`;return n.emit(r,a,s)})),oe=(e,t,n)=>v((s=>{let i=s.gen(e),a=s.gen(t),[r,o]=s.useVariables(\"roundVal\",\"div\"),l=`\\n${s.varKeyword} ${o} = ${i.variable} / ${a.variable};\\n`,u=\"\";switch(n){case\"ceil\":u=s.target===m.C?M[\"Math.ceil\"]:\"Math.ceil\";break;case\"trunc\":u=\"Math.trunc\";break;case\"floor\":u=s.target===m.C?M[\"Math.floor\"]:\"Math.floor\";break;case\"nearest\":u=s.target===m.C?M[\"Math.round\"]:\"Math.round\"}return l+=`\\n${s.varKeyword} ${r} = ${a.variable} * ${u}(${o});\\n`,s.emit(l,r,i,a)})),le=e=>U(2,e),ue={min:0,max:1},me=(e,t=0,n=ue)=>v((s=>{let i=n.max-n.min;return(\"phasor\",a=accum(K(T(e,i),s.sampleRate),t,n),e=>{let[t]=e.useVariables(\"phasor\"),n=e.gen(a),s=`${e.varKeyword} ${t} = ${n.variable};\\n`;return e.emit(s,t,n)})(s);var a})),cycle=(e,t=0)=>v((n=>{let s=n.gen(e),i=n.gen(t),a=se(E(me(e),t),0,1)(n),[r,o,l,u,h]=n.useVariables(\"floatIndex\",\"frac\",\"clerp\",\"index\",\"nextIndex\");const d=n.target===m.C?\"sineTable\":\"this.sineTable\";let p=n.intKeyword,c=n.varKeyword,$=n.target===m.C?M[\"Math.floor\"]:\"Math.floor\",y=`\\n${a.code}\\n${n.varKeyword} ${r} = ${a.variable} * 1024;\\n${n.varKeyword} ${o} = ${r} - ${$}(${r});\\n${p} ${u} = ${$}(${r});\\n${p} ${h} = ${u} + 1;\\nif (${h} >= 1024) {\\n  ${h} = 0;\\n}\\n${c} ${l} = (1.0-${o})*${d}[${u}] + ${o}*${d}[${h}];\\n`;return n.emit(y,l,s,i)})),he=e=>t=>{let n=t.gen(e),s=`\\nif (${n.variable}) {\\n  break;\\n}\\n`;return t.emit(s,\"\",n)},de=(e=1,t=1,n,s,i)=>{let a,r,o,l=[],u=i=>{o&&(n=o);let u=i;if(void 0===a||r!==i){if(s)for(;\"context\"in u;)u=u.context;i=u,(!a||i.context!==r&&r.context!==i)&&(i===r||(a=i.alloc(e*t))),a.initData=n,a.length=e,a.channels=t,l.push({block:a,context:i})}return r=i,a.channels=t,a.length=e,null!=n&&(a.initData=n),i.memory.blocksInUse.push(a),a};return u.get=()=>a?a.get():new Promise((e=>e(new Float32Array(1)))),u.interpolation=void 0===i?\"linear\":i,u.getSize=()=>e,u.getChannels=()=>t,u.getInitData=()=>n,u.set=e=>{o=e;for(let{context:t,block:n}of l)n.initData=e,t.postMessage({type:\"init-memory\",body:{idx:n.idx,data:e}})},u},pe=(e,t,n)=>v((s=>{let i=s;for(;\"context\"in s;)s=s.context;let a=e(s),r=i.gen(t),o=i.gen(n),[l,u,h,d,p,c,$,y]=i.useVariables(\"preIdx\",\"peekIdx\",\"peekVal\",\"channelIdx\",\"frac\",\"nextIdx\",\"peekIdx2\",\"peekIdx3\"),b=a.length,f=void 0===a._idx?a.idx:a._idx,g=s.intKeyword,v=s.varKeyword,x=s.target===m.C?M[\"Math.floor\"]:\"Math.floor\",w=`\\n${v} ${l} = ${r.variable};\\nif (${l} > ${a.length}) ${l} -= ${a.length};\\nelse if (${l} < 0) ${l} += ${a.length};\\n${g} ${d} = ${o.variable};\\nif (${d} > ${a.channels}) ${d} -= ${a.channels};\\nelse if (${d} < 0) ${d} += ${a.channels};\\n${g} ${u} = ${b} * ${d} + ${l};\\n${v} ${p} = ${u} - ${x}(${u});\\n${g} ${c} = ${x}(${u}) + 1;\\nif (${c} >= ${b} * (${o.variable} + 1)) {\\n   ${c} =  ${b} * (${o.variable});\\n}\\n${g} ${$} = ${f} + ${x}(${u});\\n${g} ${y} = ${f} + ${c};\\n${v} ${h} = (1 - ${p})*memory[${$}] + (${p})*memory[${y}];\\n`;return\"none\"===e.interpolation&&(w=`\\n${g} ${l} = ${r.variable};\\nif (${l} > ${a.length}) ${l} -= ${a.length};\\nelse if (${l} < 0) ${l} += ${a.length};\\n${g} ${d} = ${o.variable};\\nif (${d} > ${a.channels}) ${d} -= ${a.channels};\\nelse if (${d} < 0) ${d} += ${a.channels};\\n${g} ${u} = ${b} * ${d} + ${l};\\n${g} ${$} = ${f} + ${u};\\n${v} ${h} = memory[${$}];\\n`),s.emit(w,h,r,o)})),ce=(e,t,n,s)=>v((i=>{let a=e(i),r=i.gen(t),[o]=i.useVariables(\"pokeIdx2\"),l=i.gen(n),u=i.gen(s),h=a.length,d=i.intKeyword,p=(i.varKeyword,i.target===m.C?M[\"Math.floor\"]:\"Math.floor\"),c=`${h} * ${l.variable} + ${p}(${r.variable})`,$=`\\n// begin poke\\n${d} ${o} = ${a._idx||a.idx} + ${c};\\nmemory[${o}] = ${u.variable};\\n// end poke\\n`;return i.emit($,u.variable,r,l,u)})),$e=e=>{let t=r();return I(e,t(e))},ye=e=>{let t=r();return te(I(e,t(e)))},be=e=>{let t=r()(e);return z(0,ye(z(.5,R(K(I(e,t),E(e,t))))))},fe=(e,t)=>{let n=de(44100,1);return s=>{let i=n(s),a=s.gen(e),r=s.gen(t),[o,l,u]=s.useVariables(\"delayVal\",\"index\",\"delayIndex\"),h=accum(1,0,{min:0,max:44100,exclusive:!0})(s),d=`${i.idx} + (${h.variable})`,p=((e,t,n,s=\"memory\")=>{let i=e.idx++,a=`frac${i}`,r=`lerpVal${i}`,o=`nextIdx${i}`,l=`flooredName${i}`,u=e.target===m.C?M[\"Math.floor\"]:\"Math.floor\";return{params:[],code:`\\n${e.varKeyword} ${a} = ${n} - ${u}(${n});\\n${e.target===m.C?\"int\":\"let\"} ${o} = ${u}(${n} + 1);\\nif (${o} - ${t.idx} >= ${t.length}) ${o} = ${t.idx} + 0;\\n${e.target===m.C?\"int\":\"let\"} ${l} = ${u}(${n});\\n${e.varKeyword} ${r} = (1.0-${a})*${s}[${l}] + ${a}*${s}[${o}];\\n`,variable:r,histories:[]}})(s,i,u),c=`\\n${h.code}\\n${s.target===m.C?\"int\":\"let\"} ${l} = ${d};\\nmemory[${l}] = ${a.variable};\\n${s.target===m.C?\"int\":\"let\"} ${u} = ${l} - ${r.variable};\\nif (${u} < ${i.idx}) {\\n  ${u} += 44100;\\n}\\n${p.code}\\n${s.varKeyword} ${o} = ${p.variable};\\n`;return s.emit(c,o,a,r)}},ge=(e,t=0)=>v((n=>{let[s]=n.useVariables(\"latchVal\"),i=n.gen(e),a=n.gen(t),r=n.alloc(1),o=`${n.varKeyword} ${s} = memory[${r.idx}];\\nif (${a.variable} > 0) {\\n  memory[${r.idx}] = ${i.variable};\\n  ${s} = memory[${r.idx}];\\n}`;return n.emit(o,s,i,a)})),ve=(e,t,n)=>e.split(t).join(n);var xe=function(e,t,n,s){return new(n||(n=Promise))((function(i,a){function r(e){try{l(s.next(e))}catch(e){a(e)}}function o(e){try{l(s.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,o)}l((s=s.apply(e,t||[])).next())}))};const Me=(e,t,n=\"Zen\",s=!1)=>new Promise((i=>xe(void 0,void 0,void 0,(function*(){let{code:a,wasm:r}=we(n,t),o=a;const l=`data:application/javascript;base64,${btoa(o)}`,u=()=>{const a=new AudioWorkletNode(e,n,{channelInterpretation:\"discrete\",numberOfInputs:t.numberOfInputs,numberOfOutputs:1,channelCount:t.numberOfOutputs,outputChannelCount:[t.numberOfOutputs]});return a.port.onmessage=e=>{let n=e.data.type,s=e.data.body;t.context.onMessage({type:n,body:s}),t.context.target===m.C&&\"wasm-ready\"===n&&ze(t.context,a)},t.context.target===m.C?fetch(\"/compile\",{method:\"POST\",headers:{\"Content-Type\":\"text/plain\"},body:r}).then((e=>xe(void 0,void 0,void 0,(function*(){let t=yield e.arrayBuffer();a.port.postMessage({type:\"load-wasm\",body:t})})))):ze(t.context,a),a.port.postMessage({type:\"ready\"}),t.context.addWorklet(a),s||i({code:o,workletNode:a}),a};yield e.audioWorklet.addModule(l),s?i(u):u()})))),we=(e,t)=>{let n=[],s=\"@beginMessage\",i=\"@endMessage\",a=t.code.indexOf(s),r=1;for(;a>-1;){let e=t.code.indexOf(i);if(-1===e)break;let o=t.code.slice(a+s.length,e);n.push(o),t.context.target===m.C?t.code=t.code.slice(0,a)+\"\"+r+++t.code.slice(e+i.length):t.code=t.code.slice(0,a)+\"this.messageKey\"+r+++t.code.slice(e+i.length),a=t.code.indexOf(s)}let o=\"\";r=1;for(let e of n)o+=`this.messageKey${r} = \"${e}\";\\n`,o+=`this.messageKeys[${r-1}] = \"${e}\";\\n`,r++;const{code:l,wasm:u}=Ee(t);return{code:`\\nclass ${e}Processor extends AudioWorkletProcessor {\\n\\n  async loadWASM(wasmBuffer) {\\n    const wasmModule = await WebAssembly.compile(wasmBuffer);\\n    const importObject = {\\n    env: {\\n      memory: new WebAssembly.Memory({ initial: 256, maximum: 256 })\\n    },\\n GOT: {\\n    mem: {}\\n  }\\n   };\\n    \\n    const wasmInstance = await WebAssembly.instantiate(wasmModule, importObject);\\n    this.wasmModule = wasmInstance;\\n    this.elapsed = 0;\\n\\n    const BLOCK_SIZE = 128;\\n    this.inputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${t.numberOfInputs});\\n    this.input = new Float32Array(wasmInstance.exports.memory.buffer, this.inputPtr, BLOCK_SIZE * ${t.numberOfInputs});\\n    this.outputPtr = wasmInstance.exports.my_malloc(BLOCK_SIZE * 4 * ${t.numberOfOutputs});\\n    this.output = new Float32Array(wasmInstance.exports.memory.buffer, this.outputPtr, BLOCK_SIZE * ${t.numberOfOutputs});\\n    this.port.postMessage({type: \"wasm-ready\"});\\n    this.wasmModule.exports.initSineTable();\\n  }\\n\\n  constructor() {\\n    super();\\n    this.ready = false;\\n    this.counter=0;\\n    this.messageCounter = 0;\\n    this.disposed = false;\\n    this.id = \"${e}\";\\n    this.events = {};\\n    this.messageKey = { type: '', subType: '' };\\n    this.messageQueue = new Map(); // Map of type/subType -> array of messages\\n    this.lastMessageTime = new Map(); // Map of type/subType -> last message time\\n    this.messageInterval = 100; // Minimum interval between messages for a given type/subType (in milliseconds)\\n\\n    ${Ke(\"    \",Te(t))}\\n\\n    this.messageKeys = [];\\n    ${o}\\n\\n    this.createSineTable();\\n    \\n    this.port.onmessage = (e) => {\\n       if (e.data.type === \"memory-set\") {\\n         let {idx, value} = e.data.body;\\n         if (this.wasmModule) {\\n           this.wasmModule.exports.setMemorySlot(idx, value);\\n         } else {\\n            this.memory[idx] = value;\\n         }\\n       } else if (e.data.type === \"load-wasm\") {\\n          this.loadWASM(e.data.body);\\n       } else if (e.data.type === \"schedule-set\") {\\n\\n         let {idx, value, time} = e.data.body;\\n         if (this.wasmModule) {\\n           this.wasmModule.exports.setMemorySlot(idx, value);\\n         } else {\\n         this.events[idx] = {value, time};\\n        }\\n       } else if (e.data.type === \"init-memory\") {\\n         let {idx, data} = e.data.body;\\n         if (this.wasmModule) {\\n           for (let i=0; i < data.length; i++) {\\n             this.wasmModule.exports.setMemorySlot(idx + i, data[i]);\\n           }\\n         } else {\\n           for (let i=0; i < data.length; i++) {\\n            this.memory.set(data, idx)\\n         }\\n}\\n       } else if (e.data.type === \"memory-get\") {\\n           if (this.wasmModule) {\\n             const memPointer = this.wasmModule.exports.get_memory();\\n             const memArray  = new Float32Array(this.wasmModule.exports.memory.buffer, memPointer , this.memory.length * 3);\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: memArray.slice(idx, idx+allocatedSize)\\n             });\\n             \\n           } else {\\n             let {idx, allocatedSize} = e.data.body;\\n             this.port.postMessage({\\n               type: \"memory-get\",\\n               body: this.memory.slice(idx, idx+allocatedSize)\\n             });\\n           }\\n       } else if (e.data.type === \"dispose\") {\\n           this.disposed = true;\\n           this.memory = null;\\n       } else if (e.data.type === \"ready\") {\\n           this.ready = true;\\n       }\\n    }\\n  }\\n\\n  createSineTable() {\\n    const sineTableSize = 1024; // Choose a suitable size for the table, e.g., 4096 \\n    this.sineTable = new Float32Array(sineTableSize);\\n\\n    for (let i = 0; i < sineTableSize; i++) {\\n      this.sineTable[i] = Math.sin((2 * Math.PI * i) / sineTableSize);\\n    }\\n  }\\n\\n  scheduleEvents() {\\n      for (let idx in this.events) {\\n          let event = this.events[idx];\\n          let value = event.value;\\n          event.time--;\\n          if (event.time <= 0) {\\n             this.memory[idx] = value;\\n             delete this.events[idx];\\n          }\\n     }\\n  }\\n\\n   flushWASMMessages() {\\n      if (!this.wasmModule) {\\n         return;\\n      }\\n      let numMessages = this.wasmModule.exports.get_message_counter();\\n      const messageArrayPtr = this.wasmModule.exports.flush_messages();\\n      const messageArray = new Float32Array(this.wasmModule.exports.memory.buffer, messageArrayPtr, 1000 * 3);\\n      let messages = {\\n       };\\n      for (let i=0; i < numMessages*3; i+=3) {\\n         let type = this.messageKeys[messageArray[i]];\\n         let subType = messageArray[i+1];;\\n         let value = messageArray[i+2];;\\n         if (!messages[type]) {\\n            messages[type] = {};\\n         }\\n         messages[type][subType] = value;\\n      }\\n      for (let type in messages) {\\n          for (let subType in messages[type]) {\\n             subType = parseFloat(subType);\\nlet msg = {type, subType, body: messages[type][subType]}; \\n             this.port.postMessage(msg);\\n          }\\n      }\\n      this.wasmModule.exports.empty_messages();\\n   }\\n\\n   queueMessage(type, subType, data) {\\n    // Get the subType map for the given type\\n    let subTypeMap = this.messageQueue.get(type);\\n    if (!subTypeMap) {\\n      subTypeMap = new Map();\\n      this.messageQueue.set(type, subTypeMap);\\n    }\\n\\n    // Add the message to the queue for the given type/subType\\n    let messageQueue = subTypeMap.get(subType);\\n    if (!messageQueue) {\\n      messageQueue = [];\\n      subTypeMap.set(subType, messageQueue);\\n    }\\n    messageQueue.push(data);\\n  }\\n\\n  checkMessages() {\\n    const now = performance.now();\\n\\n    // Iterate over the message queue and send messages if the rate limit has elapsed\\n    for (const [type, subTypeMap] of this.messageQueue.entries()) {\\n      for (const [subType, messages] of subTypeMap.entries()) {\\n        // Check if enough time has elapsed since the last message of this type/subType\\n        const key = type +  \":\" + subType;\\n        const lastMessageTime = this.lastMessageTime.get(key) || 0;\\n        if (now - lastMessageTime >= this.messageInterval) {\\n          // Send the next message in the queue\\n          const data = messages.shift();\\n          this.port.postMessage({type, subType, body: data});\\n\\n          // Update the last message time for this type/subType\\n          this.lastMessageTime.set(key, now);\\n        }\\n\\n        // Remove the subType entry from the map if the queue is empty\\n        if (messages.length === 0) {\\n          subTypeMap.delete(subType);\\n          this.lastMessageTime.delete(key);\\n        }\\n      }\\n\\n      // Remove the type entry from the map if all subType queues are empty\\n      if (subTypeMap.size === 0) {\\n        this.messageQueue.delete(type);\\n      }\\n    }\\n  }\\n\\n  ${Ke(\"   \",l)}\\n}\\n\\nregisterProcessor(\"${e}\", ${e}Processor)\\n`,wasm:u}},Ee=e=>{for(let t of e.histories)e.code=ve(e.code,t,\"\");if(e.context.target===m.C){let t=(e=>`\\n#include <stdlib.h>\\n#include <emscripten.h>\\n#include <math.h>\\n#define BLOCK_SIZE 128 // The size of one block of samples\\n\\n#define MEM_SIZE ${e.context.memory.size} // Define this based on your needs\\n#define SINE_TABLE_SIZE 1024\\n#define MAX_MESSAGES 1000\\n\\nfloat memory[MEM_SIZE]; // Your memory buffer\\nfloat sineTable[SINE_TABLE_SIZE]; // Your memory buffer\\n\\nint elapsed = 0;\\n\\nstruct Message {\\n   int type;\\n   float subType;\\n   float body;\\n};\\n\\nint message_counter = 0;\\nstruct Message messages[MAX_MESSAGES];\\n\\nvoid new_message(int type, int subType, float body) {\\n   messages[message_counter].type = type;\\n   messages[message_counter].subType = subType;\\n   messages[message_counter].body = body;\\n   message_counter = (message_counter + 1);\\n   if (message_counter >= MAX_MESSAGES) {\\n     message_counter = 0;\\n   }\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nint get_message_counter() {\\n  return message_counter;\\n}\\n\\n// Get a pointer to the messages array\\nstruct Message* EMSCRIPTEN_KEEPALIVE flush_messages() {\\n   return messages;\\n}\\n\\n// Get a pointer to the messages array\\nfloat* EMSCRIPTEN_KEEPALIVE get_memory() {\\n   return memory;\\n}\\n\\nEMSCRIPTEN_KEEPALIVE \\nvoid empty_messages() {\\n   //message_counter = 0;\\n}\\n\\ndouble random_double() {\\n    return rand() / (double)RAND_MAX;\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid* my_malloc(size_t size) {\\n  return malloc(size);\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid initSineTable() {\\n   for (int i=0; i < SINE_TABLE_SIZE; i++) {\\n       sineTable[i] = sin((2 * M_PI * i) / SINE_TABLE_SIZE);\\n   }\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid init(float *mem) {\\n   for (int i=0; i < MEM_SIZE; i++) {\\n     memory[i] = mem[i];\\n   }\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid setMemorySlot(int idx, float val) {\\n  memory[idx] = val;\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid setMemoryRegion(int idx, float* val, int size) {\\n   for (int i=0 ; i < size; i++) {\\n     memory[idx + i] = val[i];\\n   }\\n}\\n\\nEMSCRIPTEN_KEEPALIVE\\nvoid process(float* inputs, float* outputs) {\\n  for (int j = 0; j < BLOCK_SIZE; j++) {\\n      ${Ie(e)}\\n      ${Se(e)}\\n      ${_e(e)}\\n      ${Ke(\"      \",e.code)}\\n      ${Ce(e)}\\n      elapsed++;\\n  }\\n}\\n`)(e);return{code:`\\nprocess(inputs, outputs, parameters) {\\n    if (this.disposed || !this.ready) {\\n      return true;\\n    }\\n    const BLOCK_SIZE = 128;\\n    let inputChannel = inputs[0];\\n    let outputChannel = outputs[0];\\n\\n    if (this.messageCounter % 10 === 0) {\\n      this.flushWASMMessages();\\n    }\\n    this.messageCounter++;\\n\\n   \\n\\n    for (let i = 0; i < 1; i ++) {\\n      if (!this.wasmModule) {\\n         return true;\\n      } \\n      for (let j = 0; j < ${e.numberOfInputs}; j++) {\\n        const inputChannel = inputs[j][0];\\n        // Copy input samples to input buffer\\n        if (inputChannel) {\\n        this.input.set(inputChannel, j * 128);\\n        }\\n      } \\n\\n      // Process samples\\n      this.wasmModule.exports.process(this.inputPtr, this.outputPtr);\\n\\n      // Copy output buffer to output channel\\n      for (let j=0; j < ${e.numberOfOutputs}; j++) {\\n     \\n         let arr = this.output.slice(j*128, (j+1)*128);\\nif (j === 1) {\\n}\\n         outputs[0][j].set(arr, 0);\\n      }\\n    }\\n    return true;\\n}\\n`,wasm:t}}return{code:`\\nprocess(inputs, outputs) {\\n    if (this.disposed || !this.ready) {\\n      return true;\\n    }\\n  let memory = this.memory;\\n \\n\\n  // note: we need to go thru each output channel for each sample\\n  // instead of how we are doing it here... or else the histories\\n  // will get all messed up.\\n  // actually, really the whole channels concept should be removed...\\n  for (let j=0; j < outputs[0][0].length; j++) {\\n      let elapsed = this.elapsed++;\\n      this.messageCounter++;\\n      this.scheduleEvents();\\n      ${Ie(e)}\\n      ${Se(e)}\\n      ${_e(e)}\\n      ${Ke(\"      \",e.code)}\\n      ${Ce(e)}\\n    }\\n  return true;\\n}\\n`,wasm:\"\"}},_e=e=>{let t=\"\",n=[];for(let s of e.histories)s=s.replace(\"let\",e.context.varKeyword)+\";\",n.includes(s)||(t+=Ke(\"   \",s)),n.push(s);return t},Se=e=>{let t=\"\";for(let n=0;n<e.numberOfOutputs;n++)t+=`${e.context.varKeyword} output${n} = 0;`;return t},Ie=e=>{let t=\"\";for(let n=0;n<e.numberOfInputs;n++)e.context.target===m.C?t+=`${e.context.varKeyword} in${n} = inputs[j + ${128*n}];\\n`:t+=`${e.context.varKeyword} in${n} = inputs[0][${n}]  ? inputs[0][${n}][j] : 0;\\n`;return t},Ce=e=>{let t=\"\";for(let n=0;n<e.numberOfOutputs;n++)e.context.target===m.C?t+=`\\noutputs[j + ${128*n}] = output${n};\\n`:t+=`\\n            outputs[0][${n}][j] = output${n};\\n            `;return t},Te=e=>`\\n            this.memory = new Float64Array(${e.context.memory.size});\\n            `,Ke=(e,t)=>t.split(\"\\n\").map((t=>e+t)).join(\"\\n\"),ze=(e,t)=>{for(let n of e.memory.blocksInUse)void 0!==n.initData&&(void 0===n._idx?n.idx:n._idx,t.port.postMessage({type:\"init-memory\",body:{idx:void 0===n._idx?n.idx:n._idx,data:n.initData}}))},Ve=(e,t)=>n=>{let[s,i]=n.useVariables(\"i\",\"sum\"),a=\"number\"==typeof e.min&&\"number\"==typeof e.max?new d(s,e,n):n,r=n.gen(e.min),o=n.gen(e.max),l=Oe(s),u=t(l)(a),m=Array.from(new Set(u.histories));m=m.map((e=>ve(e,\"let\",n.varKeyword)+\";\"));let h=Array.from(new Set(u.outerHistories));h=h.map((e=>ve(e,\"let\",n.varKeyword)+\";\"));let p=`\\n${Ke(\"    \",h.join(\"\"))}\\n${n.varKeyword} ${i} = 0;\\nfor (${n.intKeyword} ${s}=${r.variable}; ${s} < ${o.variable}; ${s}++ ) {\\n${Ke(\"    \",m.join(\"\\n\"))}\\n${Ke(\"    \",u.code)}\\n    ${i} += ${u.variable};\\n}\\n`;return n.emit(p,i)},Ae=(e,t,n)=>s=>{let[i]=s.useVariables(\"sum\"),a=\"number\"==typeof e.min&&\"number\"==typeof e.max?new d(n,e,s):s,r=s.gen(e.min),o=s.gen(e.max),l=t(a),u=Array.from(new Set(l.histories));u=u.map((e=>ve(e,\"let\",s.varKeyword)+\";\"));let m=Array.from(new Set(l.outerHistories)).filter((e=>!s.historiesEmitted.includes(e)));s.historiesEmitted=[...s.historiesEmitted,...m],m=m.map((e=>ve(e,\"let\",s.varKeyword)+\";\"));let h=`\\n${Ke(\"    \",m.join(\"\"))}\\n${s.varKeyword} ${i} = 0;\\nfor (${s.intKeyword} ${n}=${r.variable}; ${n} < ${o.variable}; ${n}++ ) {\\n${Ke(\"    \",u.join(\"\"))}\\n${Ke(\"    \",l.code)}\\n    ${i} += ${l.variable};\\n}\\n`;return s.emit(h,i)},Oe=e=>t=>{let[n]=t.useVariables(\"loopIdx\"),s=`${t.context?t.context.intKeyword:t.intKeyword} ${n} = ${e};`,i=t.emit(s,n);return i.isLoopDependent=!0,i},Pe=(e,t,n)=>v((s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`${s.varKeyword} ${o} = ${i.variable} ? ${a.variable} : ${r.variable};`;return s.emit(l,o,i,a,r)})),ke=(e,t,n)=>s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`let ${o} = ${i.variable} ? ${a.variable} : ${r.variable}`;return s.emit(l,o,i,r)},je=(e,t,n)=>s=>{let i=s.gen(e),a=s.gen(t),r=s.gen(n),[o]=s.useVariables(\"switch\"),l=`let ${o} = ${i.variable} ? ${a.variable} : ${r.code}`;return s.emit(l,o,i,a)},Le=w(\"Math.random\",\"random\"),Ne=(e,t,n,s,i)=>v((a=>{let r=a.gen(e),o=a.gen(t),l=a.gen(s),u=a.gen(n),m=a.gen(i),h=a.idx++,d=`scaleVal${h}`,p=`range1${h}`,c=`range2${h}`,$=\"number\"==typeof t&&\"number\"==typeof n?n-t:`${u.variable} - ${o.variable}`,y=\"number\"==typeof s&&\"number\"==typeof i?i-s:`${m.variable} - ${l.variable}`,b=`${a.varKeyword} ${p} = ${$};\\n${a.varKeyword} ${c} = ${y};\\n${a.varKeyword} ${d} = ${p} == 0 ? ${l.variable} : \\n    (((${r.variable} - ${o.variable}) * ${c}) / ${p}) + ${l.variable};`;return a.emit(b,d,r,o,u,l,m)})),Re=(...e)=>t=>{let n=\"\\n/** SEQ START **/\",s=\"\",i=[],a=[],r=[],o=0;for(let l of e){if((new Date).getTime(),\"function\"!=typeof l)continue;let e=l(t);r=[...r,...e.params],n+=\" \"+e.code+\";\",s=e.variable,t.emittedVariables[s]=!0,e.histories&&(i=[...i,...e.histories]),e.outerHistories&&(a=[...a,...e.outerHistories]),(new Date).getTime(),e.outputs>o&&(o=e.outputs)}return n+=\"/** SEQ END **/\",{outputs:o,params:r,code:n,variable:s,histories:i,outerHistories:a}};class De{constructor(e,t,n){this.connections=[],this.isEntryPoint=n,this.material=e,this.web=t,this.neighbors=de(t.size*t.maxNeighbors,1,t.neighbors,!0,\"none\"),this.coeffs=t.data,this.dampening=t.dampeningData,this.nt2=ne(U(2,-8),U(2,-13),e.release),this.u=de(t.size,3,void 0,!0,\"none\"),this.currentChannel=accum(1,0,{min:0,max:2,exclusive:!1}),this.prevChannel=I(this.currentChannel,1),this.u_center=pe(this.u,0,this.prevChannel),this.tension=ne(U(2,-12),U(2,-5),.0999151),this.p0=ne(11044095e-20,.01,e.pitch),this.p_eff=Y(.47,E(this.p0,U(T(this.u_center,this.tension,1),2)))}get size(){return this.web.size}gen(e){return this.isEntryPoint&&(this.excitementEnergy=e),Re(this.currentChannel,this.prevChannel,e,this.nt2,this.u_center,this.tension,this.p0,this.material.couplingCoefficient,this.p_eff,T(K(200,this.size),Ve({min:0,max:this.size},(t=>this.nodeDisplacement(e,t)))))}nodeDisplacement(e,t){let n=pe(this.u,t,this.prevChannel),s=this.calculateNeighborsEnergy(t,n,e),i=(j(t,D(this.material.placement)),T(e,this.lerpExcitementEnergy(t,this.material.x,this.material.y))),a=pe(this.u,t,I(this.currentChannel,2)),r=ne(U(2,-8),U(2,-13),T(pe(this.dampening,t,0),this.material.release)),o=K(E(T(2,n),T(this.p_eff,E(s,T(1,i),T(-4,n))),T(-1,I(1,r),a)),E(1,r));return Re(ce(this.u,t,this.currentChannel,Y(1,ee(-1,o))),o)}lerpExcitementEnergy(e,t,n){let s=T(e,2),i=pe(this.web.pointsData,s,0),a=pe(this.web.pointsData,E(s,1),0),r=J(E(U(I(i,t),2),U(I(a,n),2))),o=ie(I(1,K(r,80)),0,1);return X(K((e=>T(-1,e))(U(r,2)),T(2,U(K(80,2),2)))),o}calculateNeighborsEnergy(e,t,n){let s=Y(20,this.material.noise),i=T(Ne(Le(),0,1,-1,1),s);this.connections[0]&&this.connections[0].component.isEntryPoint&&(n=this.connections[0].component.excitementEnergy);let a=T(.5,E(T(ne(U(n,.5),t,1),i),this.sumNeighbors(e,this.prevChannel,this.web.maxNeighbors,this.u,this.neighbors,this.coeffs)));for(let n of this.connections){let{component:s,neighbors:i}=n,r=pe(i,e,0),o=L(r,-1),l=pe(s.u,r,s.prevChannel),u=I(l,t),m=Pe(o,T(u,this.material.couplingCoefficient),0);a=E(a,m)}return a}sumNeighbors(e,t=this.prevChannel,n,s=this.u,i=this.neighbors,a=this.coeffs){return Ve({min:0,max:n+1},(r=>{let o=pe(i,E(T(n,e),r),0),l=pe(a,o,e);return Re(Pe(L(o,-1),T(Pe(j(l,-1),T(-1,pe(s,e,t)),pe(s,o,t)),l),0))}))}connect(e,t){let n=de(e.size*t.maxNeighbors,1,t.neighbors);return de(e.size,e.size,t.coeffs),this.connections.push({component:e,neighbors:n}),this}bidirectionalConnect(e){let t,n;if(e.size<this.size){let[s,i]=Be(e,this);t=s,n=i}else{let[s,i]=Be(this,e);t=i,n=s}let s=de(t.length,1,t,!0,\"none\"),i=de(n.length,1,n,!0,\"none\");this.connections.push({component:e,neighbors:i}),e.connections.push({component:this,neighbors:s})}}const Be=(e,t)=>{let n=new Float32Array(e.size);for(let s=0;s<e.size;s++)n[s]=t.size-1-s;let s=new Float32Array(t.size),i=t.size-e.size;for(let e=0;e<t.size;e++)s[e]=e<i?-1:t.size-e-1;return[n,s]},qe=(e,t=\"hello\")=>{let n=r(e,{inline:!1,name:t}),s=n();return s.set=(e,t)=>{n.value(e,t)},s},Fe=(...e)=>t=>{let n=e.map((e=>t.gen(e))),s=`\\nif (/*${n[0].variable} > 0 &&*/  this.counter++ < 5000 && this.counter % 2 >= 0) {\\nconsole.log(${n.map((e=>e.variable)).join(\",\")});\\n}\\n        `;return t.emit(s,n[0].variable,...n)},Ze=e=>v((t=>{let[n]=t.useVariables(\"t60\"),s=t.gen(e),i=t.target===m.C?M[\"Math.exp\"]:\"Math.exp\",a=`\\n${t.varKeyword} ${n} = ${i}(-6.907755278921 / ${s.variable});\\n`;return t.emit(a,n,s)})),We=(e=44100)=>{let t=r(),n=t(T(t(),Ze(e)));return n.trigger=()=>{t.value(1)},n},He=(e,t=44100)=>{let n=r();return n(ne(e,n(),Ze(t)))},Qe=(e,t=.5)=>Pe(z(e,t),Ne(e,0,t,0,1),Ne(e,t,1,1,0)),Ue=(e,t=1e4,n=1e4,s=.8,i=1e4,a=4e3)=>{let o=r(void 0,{inline:!0}),l=r(),u=k(e,l()),m=accum(o(),u,{min:0,max:1/0}),h=E(t,n),d=Pe(z(m,t),K(m,t),Pe(z(m,h),Ne(m,t,h,1,s),s)),p=r(),c=p(T(o(),Pe(A(u,0),o(y(1)),Pe(P(z(m,a),z(m,t)),U(K(m,t),2),Pe(P(z(m,a),z(m,h)),Ne(m,t,h,1,s),Pe(z(m,a),s,Pe(z(m,E(a,i)),ie(T(d,I(1,K(I(m,a),i))),0,1),o(y(0))))))))),$=r();return Re(Pe(P($(),A(p(),1e-5)),p(T(p(),.001)),Pe($(),Re(l(y(1)),T(0,$(y(0)))),Pe(P(A(u,0),A(p(),.01)),T(0,$(y(1))),Re(c,l(y(0)))))))},Ge=e=>Ne(Z(T(Math.PI,e)),1,-1,0,1),Xe=e=>t=>{let n=t.gen(e),[s]=t.useVariables(\"ms\"),i=`${t.varKeyword} ${s} = 1000.0*${n.variable}/${t.sampleRate};`;return t.emit(i,s,n)},Je=e=>t=>{let n=t.gen(e),[s]=t.useVariables(\"samps\"),i=`${t.varKeyword} ${s} = (${n.variable}/1000)*${t.sampleRate};`;return t.emit(i,s,n)},Ye=e=>{let t=r();return I(e,t(ne(e,t(),.999)))},et=()=>e=>{let[t]=e.useVariables(\"elapsed\"),n=`${e.varKeyword} ${t} = elapsed;`;return console.log(\"calling elapsed\"),e.emit(n,t)},tt=e=>t=>{let n=t.gen(e),[s]=t.useVariables(\"fixed\"),i=t.target===m.C?\"isnan\":\"isNaN\",a=`${t.varKeyword} ${s} = ${i}(${n.variable}) ? 0.0 : ${n.variable};`;return t.emit(a,s,n)};return t})()));;window.ZEN_LIB = zen; Object.keys(ZEN_LIB).forEach(key => window[key] = ZEN_LIB[key]);";
    }
}
